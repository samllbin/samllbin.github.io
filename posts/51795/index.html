<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>你不知道的UseState在mount阶段时所执行时机 | samllBin's 小窝</title><meta name="author" content="samllBin"><meta name="copyright" content="samllBin"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="你不知道的函数式组件在 mount 阶段的流程和其 hook 所执行的时机提出问题想必用过 React 的对 UseState 应该并不陌生，但是你知道其在 mount 阶段的执行的时机吗？ ​ 先思考一个问题：当我们在非 FC(函数式组件)中使用 hook 时会出现什么情况呢？会出现如下的错误:  那么 Hook 本身作为一个函数是如何知道当前它的上下文的呢？React 的解决方法就是：在不同上">
<meta property="og:type" content="article">
<meta property="og:title" content="你不知道的UseState在mount阶段时所执行时机">
<meta property="og:url" content="http://example.com/posts/51795/index.html">
<meta property="og:site_name" content="samllBin&#39;s 小窝">
<meta property="og:description" content="你不知道的函数式组件在 mount 阶段的流程和其 hook 所执行的时机提出问题想必用过 React 的对 UseState 应该并不陌生，但是你知道其在 mount 阶段的执行的时机吗？ ​ 先思考一个问题：当我们在非 FC(函数式组件)中使用 hook 时会出现什么情况呢？会出现如下的错误:  那么 Hook 本身作为一个函数是如何知道当前它的上下文的呢？React 的解决方法就是：在不同上">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/img/youdonotkonw.jpg">
<meta property="article:published_time" content="2023-11-03T10:03:01.000Z">
<meta property="article:modified_time" content="2023-11-05T07:16:40.236Z">
<meta property="article:author" content="samllBin">
<meta property="article:tag" content="React">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/img/youdonotkonw.jpg"><link rel="shortcut icon" href="/img/1.jpg"><link rel="canonical" href="http://example.com/posts/51795/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":false,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: true
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体中文","cht_to_chs":"你已切换为简体中文","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#2d3035","position":"bottom-left"},
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '你不知道的UseState在mount阶段时所执行时机',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-11-05 15:16:40'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
          const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
          const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
          const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

          if (t === undefined) {
            if (isLightMode) activateLightMode()
            else if (isDarkMode) activateDarkMode()
            else if (isNotSpecified || hasNoSupport) {
              const now = new Date()
              const hour = now.getHours()
              const isNight = hour <= 8 || hour >= 22
              isNight ? activateDarkMode() : activateLightMode()
            }
            window.matchMedia('(prefers-color-scheme: dark)').addListener(e => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><link rel="stylesheet" href="/css/mouse.css"><meta name="generator" content="Hexo 7.0.0"></head><body><div id="web_bg">     </div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/1.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">3</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">1</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">1</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/youdonotkonw.jpg')"><nav id="nav"><span id="blog-info"><a href="/" title="samllBin's 小窝"><span class="site-name">samllBin's 小窝</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">你不知道的UseState在mount阶段时所执行时机</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-11-03T10:03:01.000Z" title="发表于 2023-11-03 18:03:01">2023-11-03</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-11-05T07:16:40.236Z" title="更新于 2023-11-05 15:16:40">2023-11-05</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/React/">React</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">3.5k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>13分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="你不知道的UseState在mount阶段时所执行时机"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h2 id="你不知道的函数式组件在-mount-阶段的流程和其-hook-所执行的时机"><a href="#你不知道的函数式组件在-mount-阶段的流程和其-hook-所执行的时机" class="headerlink" title="你不知道的函数式组件在 mount 阶段的流程和其 hook 所执行的时机"></a>你不知道的函数式组件在 mount 阶段的流程和其 hook 所执行的时机</h2><h3 id="提出问题"><a href="#提出问题" class="headerlink" title="提出问题"></a>提出问题</h3><p>想必用过 React 的对 UseState 应该并不陌生，但是你知道其在 mount 阶段的执行的时机吗？</p>
<p>​ 先思考一个问题：当我们在非 FC(函数式组件)中使用 hook 时会出现什么情况呢？会出现如下的错误:</p>
<p><img src="/../img/Snipaste_2023-10-14_17-12-48.png"></p>
<p>那么 Hook 本身作为一个函数是如何知道当前它的上下文的呢？React 的解决方法就是：在不同上下文中所调用的 Hook 是不同的，并且实现了一个内部数据共享层。大致的情况如下：</p>
<p><img src="/../img/hook.drawio.png"></p>
<p>​</p>
<p>​ 还有一个问题是 Hook 数据保存在哪里，在类组件中我们知道保存在 state 中，而在 FC 中每次更新都是函数的重新执行，所以不能保存在函数里，那么只能保存在 FC 对应的 fiberNode 上，只要这个 FC 还存在那么这个 fiberNode 就不会销毁。其保存的形式大致如下：</p>
<p><img src="/../img/hookneibu.drawio.png"></p>
<p>​</p>
<h3 id="mount-的大致流程："><a href="#mount-的大致流程：" class="headerlink" title="mount 的大致流程："></a>mount 的大致流程：</h3><p>在这我们只考虑单节点，如下结构</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">App</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> [num] = <span class="title function_">useState</span>(<span class="number">100</span>);</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">sapn</span>&gt;</span>&#123;num&#125;<span class="tag">&lt;/<span class="name">sapn</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">ReactDOM</span>.<span class="title function_">createRoot</span>(<span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;root&quot;</span>)!).<span class="title function_">render</span>(<span class="language-xml"><span class="tag">&lt;<span class="name">App</span> /&gt;</span></span>);</span><br></pre></td></tr></table></figure>

<h4 id="调度准备阶段"><a href="#调度准备阶段" class="headerlink" title="调度准备阶段"></a>调度准备阶段</h4><p>​ 在我们的 React 的项目中 src 文件夹下的 index.js 文件中会有如下代码</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> root = <span class="title class_">ReactDOM</span>.<span class="title function_">createRoot</span>(<span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;root&quot;</span>));</span><br><span class="line">root.<span class="title function_">render</span>(</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">React.StrictMode</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">App</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">React.StrictMode</span>&gt;</span></span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">//index.html</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;root&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br></pre></td></tr></table></figure>

<p>这就是 mount 阶段的入口，我们看一下 ReactDOM 下 createRoot 函数所做的事情，下面为导出的函数：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">createRoot</span>(<span class="params">container: Container</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> root = <span class="title function_">createContainer</span>(container);</span><br><span class="line">  <span class="comment">//...其他代码</span></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="title function_">render</span>(<span class="params">element: ReactElementType</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="title function_">updateContainer</span>(element, root);</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个 container 你可以想象成一个容器，即为传进来的 div 元素，createContainer 函数所做的事情就是创建 HostRootFiber 和 FiberRootNode，那么可能又有人会问 HostRootFiber 和 FiberRootNode 是什么呢？这个在这就不介绍过多，想要了解更多请查看别的资料，我就用一张图片来表示：</p>
<p><img src="/../img/fiber.drawio.png"></p>
<p>这个 FiberRootNode 用来切换 current 和 workInProgress 树来实现双缓冲树，这个 HostRootFiber 对应的即为 root 对应的 element 对应的 Fiber。</p>
<p>可以看到返回一个对象其中包含一个 render 函数，其中又调用了 updateContainer，这个 updateContainer 的作用大致就是为 root 添加一个 Update，然后开启调度，记住这个 hostRootFiber 和 updateQueue，后面要考哦。<strong>注意：我们在 React 提到的 root 对应的应该是 FiberRootNode，而不是 HostRootFiber。</strong></p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">updateContainer</span>(<span class="params"></span></span><br><span class="line"><span class="params">  element: ReactElementType | <span class="literal">null</span>,</span></span><br><span class="line"><span class="params">  root: FiberRootNode</span></span><br><span class="line"><span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> hostRootFiber = root.<span class="property">current</span>;</span><br><span class="line">  <span class="comment">//&lt;App/&gt;对应的element</span></span><br><span class="line">  <span class="keyword">const</span> update = createUpdate&lt;<span class="title class_">ReactElementType</span> | <span class="literal">null</span>&gt;(element);</span><br><span class="line">  <span class="title function_">enqueueUpdate</span>(</span><br><span class="line">    hostRootFiber.<span class="property">updateQueue</span> <span class="keyword">as</span> <span class="title class_">UpdateQueue</span>&lt;<span class="title class_">ReactElementType</span> | <span class="literal">null</span>&gt;,</span><br><span class="line">    update</span><br><span class="line">  );</span><br><span class="line">  <span class="title function_">scheduleUpdateOnFiber</span>(hostRootFiber);</span><br><span class="line">  <span class="keyword">return</span> element;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="调度阶段"><a href="#调度阶段" class="headerlink" title="调度阶段"></a>调度阶段</h4><p>​ 在调度阶段我们会执行下列几项操作：</p>
<ul>
<li>向上遍历到 root，（这是 mount 阶段，所以 hostRootFiber.stateNode 即可，但在 update 中可能发生在任意一个 fiber 上）</li>
<li>调用 renderRoot</li>
<li>初始化 wip 树</li>
<li>beginWork 阶段</li>
<li>completeWork 阶段</li>
<li>commitWork 阶段</li>
<li>commit 阶段</li>
</ul>
<p>在这我们探讨 FC 的 mount 阶段，如果想了解其他类型的 mount 阶段可以关注后续发的文章。</p>
<h5 id="向上遍历"><a href="#向上遍历" class="headerlink" title="向上遍历"></a>向上遍历</h5><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">markUpdateFromFiberToRoot</span>(<span class="params">fiber: FiberNode</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> node = fiber;</span><br><span class="line">  <span class="keyword">let</span> parent = node.<span class="property">return</span>;</span><br><span class="line">  <span class="keyword">while</span> (parent !== <span class="literal">null</span>) &#123;</span><br><span class="line">    node = parent;</span><br><span class="line">    parent = node.<span class="property">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//hostRootFiber.tag = HostRoot</span></span><br><span class="line">  <span class="keyword">if</span> (node.<span class="property">tag</span> === <span class="title class_">HostRoot</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> node.<span class="property">stateNode</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="renderRoot-函数"><a href="#renderRoot-函数" class="headerlink" title="renderRoot 函数"></a>renderRoot 函数</h5><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">renderRoot</span>(<span class="params">root: FiberRootNode</span>) &#123;</span><br><span class="line">  <span class="comment">//初始化</span></span><br><span class="line">  <span class="title function_">prepareFreshStack</span>(root);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="title function_">workLoop</span>();</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">      <span class="keyword">if</span> (__DEV__) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">warn</span>(<span class="string">&quot;workLoop发生错误&quot;</span>, e);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">while</span> (<span class="literal">true</span>);</span><br><span class="line">  <span class="keyword">const</span> finishedWork = root.<span class="property">current</span>.<span class="property">alternate</span>;</span><br><span class="line">  root.<span class="property">finishedWork</span> = finishedWork;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">commitRoot</span>(root);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="初始化-wip-树"><a href="#初始化-wip-树" class="headerlink" title="初始化 wip 树"></a>初始化 wip 树</h5><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">prepareFreshStack</span>(<span class="params">root: FiberRootNode</span>) &#123;</span><br><span class="line">  workInprogress = <span class="title function_">createWorkInProgress</span>(root.<span class="property">current</span>, &#123;&#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//createWorkInProgress</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> createWorkInProgress = (</span><br><span class="line">  <span class="attr">current</span>: <span class="title class_">FiberNode</span>,</span><br><span class="line">  <span class="attr">pendingProps</span>: <span class="title class_">Props</span></span><br><span class="line">): <span class="function"><span class="params">FiberNode</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> wip = current.<span class="property">alternate</span>;</span><br><span class="line">  <span class="keyword">if</span> (wip === <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">//mount</span></span><br><span class="line">    wip = <span class="keyword">new</span> <span class="title class_">FiberNode</span>(current.<span class="property">tag</span>, pendingProps, current.<span class="property">key</span>);</span><br><span class="line">    <span class="comment">//其他代码</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//其他代码</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="beginWork"><a href="#beginWork" class="headerlink" title="beginWork"></a>beginWork</h5><p>​ beginWork 的作用大致可以表达为：根据子的 current fiberNode 和 reactElement，生成子对应的 fiberNode，并且打上相对应的 flags,然后返回子 fiberNode，由于是 mount 阶段，只会有 Placement Flag(插入)。</p>
<p>​ 进入 beginWork 后根据不同的 fiber.tag 进入不同的流程：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">beginWork</span> = (<span class="params">wip: FiberNode</span>) =&gt; &#123;</span><br><span class="line">  <span class="comment">//与React Element比较，生成FiberNode，然后再返回子FiberNode</span></span><br><span class="line">  <span class="keyword">switch</span> (wip.<span class="property">tag</span>) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="title class_">HostRoot</span>:</span><br><span class="line">      <span class="keyword">return</span> <span class="title function_">updateHostRoot</span>(wip);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> <span class="title class_">HostComponent</span>:</span><br><span class="line">      <span class="keyword">return</span> <span class="title function_">updateHostComponent</span>(wip);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> <span class="title class_">HostText</span>:</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> <span class="title class_">FunctionComponent</span>:</span><br><span class="line">      <span class="keyword">return</span> <span class="title function_">updateFunctionComponent</span>(wip);</span><br><span class="line">    <span class="attr">default</span>:</span><br><span class="line">      <span class="keyword">if</span> (__DEV__) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">warn</span>(<span class="string">&quot;workloop未实现的类型&quot;</span>, wip);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h6 id="hostRootFiber-beginWork——首屏渲染优化"><a href="#hostRootFiber-beginWork——首屏渲染优化" class="headerlink" title="hostRootFiber beginWork——首屏渲染优化"></a>hostRootFiber beginWork——首屏渲染优化</h6><p>​ 第一个进入的当然是 hostRootFiber，本来应该不在这提的，但是由于其中包含一个关于 react 首屏渲染的优化，所以还是在这里提一下，如果你已经了解了，那么可以直接跳到下一个 fiberNode 的 beginWork 中。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">updateHostRoot</span>(<span class="params">wip: FiberNode</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> baseState = wip.<span class="property">memoizedState</span>;</span><br><span class="line">  <span class="keyword">const</span> updateQueue = wip.<span class="property">updateQueue</span> <span class="keyword">as</span> <span class="title class_">UpdateQueue</span>&lt;<span class="title class_">Element</span>&gt;;</span><br><span class="line">  <span class="keyword">const</span> pending = updateQueue.<span class="property">shared</span>.<span class="property">pending</span>;</span><br><span class="line">  updateQueue.<span class="property">shared</span>.<span class="property">pending</span> = <span class="literal">null</span>;</span><br><span class="line">  <span class="comment">//memoizedState为传递进来的React Element,&lt;APP/&gt;组件</span></span><br><span class="line">  <span class="keyword">const</span> &#123; memoizedState &#125; = <span class="title function_">processUpdateQueue</span>(baseState, pending);</span><br><span class="line">  wip.<span class="property">memoizedState</span> = memoizedState;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> nextChildren = wip.<span class="property">memoizedState</span>;</span><br><span class="line">  <span class="title function_">reconcileChildren</span>(wip, nextChildren);</span><br><span class="line">  <span class="keyword">return</span> wip.<span class="property">child</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​ 在 updateContainer 函数中我们已经为 hostRootFiber 创建了一个 update，这个 update 就是来帮助我们创建 App 组件对应的 fiberNode 的，消费完这个 update 后就能获得到 children 的信息。还记得在上面让记住的 hostRootFiber 嘛，为什么我们要在未进行调度的时候就创建 hostRootFiber 并在它的 updateQueue 上添加一个 update，这个就 reconcileChildren 函数有关了，别着急继续往下面看：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">reconcileChildren</span>(<span class="params">wip: FiberNode, children?: ReactElementType</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> current = wip.<span class="property">alternate</span>;</span><br><span class="line">  <span class="keyword">if</span> (current !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">//update</span></span><br><span class="line">    wip.<span class="property">child</span> = <span class="title function_">reconcileChildFibers</span>(wip, current?.<span class="property">child</span>, children);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//mount</span></span><br><span class="line">    wip.<span class="property">child</span> = <span class="title function_">mountChildFibers</span>(wip, <span class="literal">null</span>, children);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> reconcileChildFibers = <span class="title class_">ChildReconciler</span>(<span class="literal">true</span>);</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> mountChildFibers = <span class="title class_">ChildReconciler</span>(<span class="literal">false</span>);</span><br></pre></td></tr></table></figure>

<p>​ 这两个函数都是由 ChildReconciler 函数返回的，唯一的不同点在于 shouldTrackEffects：是否追踪副作用这个参数的不同，区分进入不同树的依据就是 wip.alternate 是否存在这个 fiber.alternate 就是 current 树上的 fiberNode，两棵树的 fiberNode 通过 alternate 连接，即 wip.alternate &#x3D; currentFiberNode,currentFiberNode.alternate &#x3D; wip。这就是我们在调度之前创建 hostRootFiber 的原因，这样就能只让 hostRootFiber 进入 reconcileChildFibers 函数中。因为只有 hostRootFiber.alternate !&#x3D;&#x3D; null。</p>
<p>​ 那么区分 hostRootFiber 和其他 fiber 有什么用呢？还记得为什么要提 hostRootFiber 的 beginWork 流程吗？对，首屏渲染。因为是 mount 阶段不像后续的 update 阶段只需更新部分 fiberNode 的状态，而在这我们需要创建 fiberNode，并且将它们一个一个插在父 fiberNode 中去，如果首屏渲染的组件很多那么就要消费很多 Placement flag，所以为了解决首屏渲染的速度问题，我们可以先构建一棵离屏的 DOM 树，在都构建完成之后，一并插入到 hostRootFiber 中去，这时我们仅仅需要消费一个 Placement flag。到这是不是很清晰了，我们需要打上 Flag 的 fiberNode 正是 App 组件所对应的 fiberNode 中，下面来看一下具体的实现：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">placeSingleChild</span>(<span class="params">fiber: FiberNode</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (shouldTrackEffects &amp;&amp; fiber.<span class="property">alternate</span> === <span class="literal">null</span>) &#123;</span><br><span class="line">    fiber.<span class="property">flags</span> |= <span class="title class_">Placement</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> fiber;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为我们在调度之前只创建了 hostRootFiber 和 fiberRootNode，所以 App 对应的 current 树下的 fiberNode 是不存在的，所以会打上 Placement。</p>
<p>​ 完整的 ChildReconciler 函数，有兴趣的可以看一下，有什么不明白的可以提问：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">ChildReconciler</span>(<span class="params">shouldTrackEffects: <span class="built_in">boolean</span></span>) &#123;</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">reconcileSingleElement</span>(<span class="params"></span></span><br><span class="line"><span class="params">    returnFiber: FiberNode,</span></span><br><span class="line"><span class="params">    currentFiber: FiberNode | <span class="literal">null</span>,</span></span><br><span class="line"><span class="params">    element: ReactElementType</span></span><br><span class="line"><span class="params">  </span>) &#123;</span><br><span class="line">    <span class="comment">//根据ReactElement创建一个fiber然后返回</span></span><br><span class="line">    <span class="keyword">const</span> fiber = <span class="title function_">createFiberFromElement</span>(element);</span><br><span class="line">    fiber.<span class="property">return</span> = returnFiber;</span><br><span class="line">    <span class="keyword">return</span> fiber;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">reconcileSingeTextNode</span>(<span class="params"></span></span><br><span class="line"><span class="params">    returnFiber: FiberNode,</span></span><br><span class="line"><span class="params">    currentFiber: FiberNode | <span class="literal">null</span>,</span></span><br><span class="line"><span class="params">    content: <span class="built_in">string</span> | <span class="built_in">number</span></span></span><br><span class="line"><span class="params">  </span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> fiber = <span class="keyword">new</span> <span class="title class_">FiberNode</span>(<span class="title class_">HostText</span>, &#123; content &#125;, <span class="literal">null</span>);</span><br><span class="line">    fiber.<span class="property">return</span> = returnFiber;</span><br><span class="line">    <span class="keyword">return</span> fiber;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//插入单一的节点</span></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">placeSingleChild</span>(<span class="params">fiber: FiberNode</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (shouldTrackEffects &amp;&amp; fiber.<span class="property">alternate</span> === <span class="literal">null</span>) &#123;</span><br><span class="line">      fiber.<span class="property">flags</span> |= <span class="title class_">Placement</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fiber;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> <span class="title function_">reconcileChildFibers</span>(<span class="params"></span></span><br><span class="line"><span class="params">    returnFiber: FiberNode,</span></span><br><span class="line"><span class="params">    currentFiber: FiberNode | <span class="literal">null</span>,</span></span><br><span class="line"><span class="params">    newChild?: ReactElementType</span></span><br><span class="line"><span class="params">  </span>) &#123;</span><br><span class="line">    <span class="comment">//判断当前fiber的类型</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> newChild === <span class="string">&quot;object&quot;</span> &amp;&amp; newChild !== <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">switch</span> (newChild.<span class="property">$$typeof</span>) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="attr">REACT_ELEMENT_TYPE</span>:</span><br><span class="line">          <span class="keyword">return</span> <span class="title function_">placeSingleChild</span>(</span><br><span class="line">            <span class="title function_">reconcileSingleElement</span>(returnFiber, currentFiber, newChild)</span><br><span class="line">          );</span><br><span class="line"></span><br><span class="line">        <span class="attr">default</span>:</span><br><span class="line">          <span class="keyword">if</span> (__DEV__) &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">warn</span>(<span class="string">&quot;未实现的reconcile类型&quot;</span>, newChild);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//HostText</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> newChild === <span class="string">&quot;string&quot;</span> || <span class="keyword">typeof</span> newChild === <span class="string">&quot;number&quot;</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="title function_">placeSingleChild</span>(</span><br><span class="line">        <span class="title function_">reconcileSingeTextNode</span>(returnFiber, currentFiber, newChild)</span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (__DEV__) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">warn</span>(<span class="string">&quot;未实现的reconcile类型&quot;</span>, newChild);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">//其他代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="FC-beginWork"><a href="#FC-beginWork" class="headerlink" title="FC beginWork"></a>FC beginWork</h6><p>​ 接下来就要进入我们的 FC beginWork 了，接下来我们要进入这个函数 updateFunctionComponent。这时候想想 FC 的结构，jsx 放在 return 中，那么我们要创建子 fiberNode 肯定要拿到其 return 出来的结果就是 nextChildren 并处理。那么是不是拿到这个函数并且执行是不是就可以了，这个函数就该 fiber 对应的 type 上：</p>
<p><img src="/../img/Snipaste_2023-10-14_19-11-40.png"></p>
<p>​</p>
<p>拿到这个函数是不是就可以开始执行了，传入相对应的 props，函数开始执行，碰到 useState。在开始后续的步骤时先提几个概念，</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = &#123;</span><br><span class="line">  currentDispatcher,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这个 __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED 就是前面提到的内部数据共享层，其中包括了一个 currentDispatcher，这个就相当于上面那张图中的当前可使用的 hook 集合。currentDispatcher 的信息：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="attr">currentDispatcher</span>: &#123; <span class="attr">current</span>: <span class="title class_">Dispatcher</span> | <span class="literal">null</span> &#125; = &#123;</span><br><span class="line">  <span class="attr">current</span>: <span class="literal">null</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>我们在使用 react 的 hook 时都知道从 react 这个包中引入，那么在 react 包中暴露出去的 hook：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="attr">useState</span>: <span class="title class_">Dispatcher</span>[<span class="string">&quot;useState&quot;</span>] = <span class="function">(<span class="params">initialState</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">//获取当前上下文中所以的hook,并从中拿到useState</span></span><br><span class="line">  <span class="keyword">const</span> dispatcher = <span class="title function_">resolveDispatcher</span>();</span><br><span class="line">  <span class="keyword">return</span> dispatcher.<span class="title function_">useState</span>(initialState);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> resolveDispatcher = (): <span class="function"><span class="params">Dispatcher</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> dispatcher = currentDispatcher.<span class="property">current</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (dispatcher === <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;hook只能在函数式组件中执行&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> dispatcher;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>先导致了解一下这些概念，没理解为什么要这么做也没关系，后续会再捋一遍。</p>
<p>​ 但是我们的调度在 react-reconciler 中，所以这个数据共享层的作用就体现出来了，我们可以在 react-reconciler 中使用这个东西了。</p>
<p>回到我们的 updateFunctionComponent 函数，其内部通过调用 renderWithHooks 函数获得其 nextChildren，看一下 nextChildren 函数：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">currentlyRenderingFiber</span>: <span class="title class_">FiberNode</span> | <span class="literal">null</span> = <span class="literal">null</span>; <span class="comment">//当前真正调度的wip</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">workInProgressHook</span>: <span class="title class_">Hook</span> | <span class="literal">null</span> = <span class="literal">null</span>; <span class="comment">//当前正在执行的hook</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">renderWithHooks</span>(<span class="params">wip: FiberNode</span>) &#123;</span><br><span class="line">  <span class="comment">//赋值</span></span><br><span class="line">  currentlyRenderingFiber = wip;</span><br><span class="line"></span><br><span class="line">  wip.<span class="property">memoizedState</span> = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> current = wip.<span class="property">alternate</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (current !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">//update</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//mount</span></span><br><span class="line">    <span class="comment">//mount时的hook</span></span><br><span class="line">    currentDispatcher.<span class="property">current</span> = <span class="title class_">HooksDispatcherOnMount</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//函数式组件的函数保存在该对应fiber的type上</span></span><br><span class="line">  <span class="keyword">const</span> <span class="title class_">Component</span> = wip.<span class="property">type</span>;</span><br><span class="line">  <span class="keyword">const</span> props = wip.<span class="property">pendingProps</span>;</span><br><span class="line">  <span class="keyword">const</span> children = <span class="title class_">Component</span>(props);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//重置</span></span><br><span class="line">  currentlyRenderingFiber = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> children;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个流程相信大家应该都不陌生了，当前传进来的是 FC 对应的 fiberNode，wip.alternate 为 null，这时候将 __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED 中的 currentDispatcher.current 进行赋值，HooksDispatcherOnMount 就对应 mount 时的 hook 集合，我们继续在下面实现这个 current</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">HooksDispatcherOnMount</span>: <span class="title class_">Dispatcher</span> = &#123;</span><br><span class="line">  <span class="attr">useState</span>: mountState,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这样是不是就能理解了 react 的 hook 为什么能感知上下文了吧。</p>
<p><strong>捋一遍逻辑</strong>：</p>
<p>​ 当我们在 FC 中使用 hook 时，实际导入的是 react 包下的 hook，但是我们并没有在那里实现，而是将它指向__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.currentDispatcher.current，我们的实现是在这个 FC 进入 beginWork 时，更具体来说是进入 renderWithHooks，我们在这个函数中给 currentDispatcher.current 赋值，所以当解析到 hook 时，找到我们在 react 包中暴露出去的 hook，而那个 hook 又指向的是当前 currentDispatcher.current 下的 hook，也就是 mountState，所以最后执行的是 mountState。还有就是当我们在函数式组件外使用 hook 时，发现当前的 currentlyRenderingFiber 是没有赋值的（进入函数式组件才会赋值），这时候就会报 hook 只能在 FC 中使用的错误，当当前的 currentDispatcher.current 是有值时我们即可将 currentDispatcher.current 指向一个全是报错的地方，调用任何一个 hook 都抛出一个错误，这就是 hook 中不能使用 hook 的实现。</p>
<p>​ 继续往下走就是执行 useState，这个没什么说的，直接上代码：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> mountState&lt;<span class="title class_">State</span>&gt;(</span><br><span class="line">  <span class="attr">initialState</span>: (<span class="function">() =&gt;</span> <span class="title class_">State</span>) | <span class="title class_">State</span></span><br><span class="line">): [<span class="title class_">State</span>, <span class="title class_">Dispatch</span>&lt;<span class="title class_">State</span>&gt;] &#123;</span><br><span class="line">  <span class="comment">//找到当前useState对应的hook数据</span></span><br><span class="line">  <span class="keyword">const</span> hook = <span class="title function_">mountWorkInProgresHook</span>(); <span class="comment">//获取当前的hook数据，创建hook，形成单向链表</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> memoizedState = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">if</span> (initialState <span class="keyword">instanceof</span> <span class="title class_">Function</span>) &#123;</span><br><span class="line">    memoizedState = <span class="title function_">initialState</span>();</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    memoizedState = initialState;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> queue = createUpdateQueue&lt;<span class="title class_">State</span>&gt;();</span><br><span class="line">  hook.<span class="property">updateQueue</span> = queue;</span><br><span class="line">  hook.<span class="property">memoizedState</span> = memoizedState;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// @ts-ignore</span></span><br><span class="line">  <span class="keyword">const</span> dispatch = dispatchSetState.<span class="title function_">bind</span>(<span class="literal">null</span>, currentlyRenderingFiber, queue);</span><br><span class="line">  queue.<span class="property">dipatch</span> = dispatch;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> [memoizedState, dispatch];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> dispatchSetState&lt;<span class="title class_">State</span>&gt;(</span><br><span class="line">  <span class="attr">fiber</span>: <span class="title class_">FiberNode</span>,</span><br><span class="line">  <span class="attr">updateQueue</span>: <span class="title class_">UpdateQueue</span>&lt;<span class="title class_">State</span>&gt;,</span><br><span class="line">  <span class="attr">action</span>: <span class="title class_">Action</span>&lt;<span class="title class_">State</span>&gt;</span><br><span class="line">) &#123;</span><br><span class="line">  <span class="keyword">const</span> update = <span class="title function_">createUpdate</span>(action);</span><br><span class="line">  <span class="title function_">enqueueUpdate</span>(updateQueue, update);</span><br><span class="line">  <span class="title function_">scheduleUpdateOnFiber</span>(fiber);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这里值得一提的是：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">App</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> [num] = <span class="title function_">useState</span>(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">sapn</span>&gt;</span>&#123;num&#125;<span class="tag">&lt;/<span class="name">sapn</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>你觉得这个 div 和 span 哪个先进入 jsx 方法，也就是 createElement 方法，答案是 span，有兴趣的可以打一个断点去看看。</p>
<p>接下来就要进入 return 出的 nextChildren 的 beginWork，一直到 HostText，然后再进行 completeWork。</p>
<h5 id="completeWork"><a href="#completeWork" class="headerlink" title="completeWork"></a>completeWork</h5><p>​ 这个阶段就是根据 beginWork 生成的 fiberNode，自下而上的去创建宿主中的实例，在浏览器中就是 element，这个使用的是浏览器提供的方法来创建，创建完成之后插入到其父 element 中去。在这个期间还会进行 flags 冒泡，什么是 flags 冒泡呢？在 beginWork 中我们为部分 fiberNode 打上了 flag，我们将这个子孙的 flag 保存在父 fiberNode 中。有人可能就会问，又进行递归会不会太消耗性能？别忘了，我们现在处在 completeWork 下，是从下到上的，刚好能够将 flags 带上去，flags 冒泡函数：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">bubbleProperties</span>(<span class="params">wip: FiberNode</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> subtreeFlags = <span class="title class_">NoFlags</span>;</span><br><span class="line">  <span class="keyword">let</span> child = wip.<span class="property">child</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (child !== <span class="literal">null</span>) &#123;</span><br><span class="line">    subtreeFlags |= child.<span class="property">subtreeFlags</span>;</span><br><span class="line">    subtreeFlags |= child.<span class="property">flags</span>;</span><br><span class="line"></span><br><span class="line">    child.<span class="property">return</span> = wip;</span><br><span class="line">    child = child.<span class="property">sibling</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  wip.<span class="property">subtreeFlags</span> = subtreeFlags;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个 subtreeFlags 保存的就是当前 fiberNode 子孙 fiberNode 所包含的 flags（不包含自己的 flags）。</p>
<p>​ 当 completeWork 结束后，一颗离屏的 DOM 树就构建好了，flags 也冒泡到了 hostRootFiber。</p>
<h5 id="commit-阶段"><a href="#commit-阶段" class="headerlink" title="commit 阶段"></a>commit 阶段</h5><p>​ commit 阶段其实和这个 mount 时期的 FC 已经没有很大的关系了，commit 阶段主要就是向下遍历找到 flags 并消费，在这里也就是 Placement，这样调度的流程就结束了。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>​ 没啥总结的，连续敲了近 3 个小时，如果有错误请各位大佬指点，如果觉得写得还行的点点赞哦，谢谢！！！</p>
<p>本文章中出现的所有代码皆是我自己实现的 react(未实现完)中拷贝出来的，能通过官方的测试样例请放心，项目地址：<a target="_blank" rel="noopener" href="https://github.com/samllbin/MyReact">https://github.com/samllbin/MyReact</a></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://example.com">samllBin</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://example.com/posts/51795/">http://example.com/posts/51795/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">samllBin's 小窝</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/React/">React</a></div><div class="post_share"><div class="social-share" data-image="/img/youdonotkonw.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-full"><a href="/posts/62212/" title="React的LifeCycle"><img class="cover" src="/img/lifeCycleImg.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">React的LifeCycle</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/posts/62212/" title="React的LifeCycle"><img class="cover" src="/img/lifeCycleImg.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-11-05</div><div class="title">React的LifeCycle</div></div></a></div><div><a href="/posts/38756/" title="用hooks实现componentWillMount"><img class="cover" src="/img/dog.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-11-13</div><div class="title">用hooks实现componentWillMount</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/1.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">samllBin</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">3</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">1</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">1</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/samllbin"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/samllbin" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="/3057988675@qq.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">更换了博客主题为butterfly</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BB%84%E4%BB%B6%E5%9C%A8-mount-%E9%98%B6%E6%AE%B5%E7%9A%84%E6%B5%81%E7%A8%8B%E5%92%8C%E5%85%B6-hook-%E6%89%80%E6%89%A7%E8%A1%8C%E7%9A%84%E6%97%B6%E6%9C%BA"><span class="toc-number">1.</span> <span class="toc-text">你不知道的函数式组件在 mount 阶段的流程和其 hook 所执行的时机</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8F%90%E5%87%BA%E9%97%AE%E9%A2%98"><span class="toc-number">1.1.</span> <span class="toc-text">提出问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#mount-%E7%9A%84%E5%A4%A7%E8%87%B4%E6%B5%81%E7%A8%8B%EF%BC%9A"><span class="toc-number">1.2.</span> <span class="toc-text">mount 的大致流程：</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B0%83%E5%BA%A6%E5%87%86%E5%A4%87%E9%98%B6%E6%AE%B5"><span class="toc-number">1.2.1.</span> <span class="toc-text">调度准备阶段</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B0%83%E5%BA%A6%E9%98%B6%E6%AE%B5"><span class="toc-number">1.2.2.</span> <span class="toc-text">调度阶段</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%90%91%E4%B8%8A%E9%81%8D%E5%8E%86"><span class="toc-number">1.2.2.1.</span> <span class="toc-text">向上遍历</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#renderRoot-%E5%87%BD%E6%95%B0"><span class="toc-number">1.2.2.2.</span> <span class="toc-text">renderRoot 函数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96-wip-%E6%A0%91"><span class="toc-number">1.2.2.3.</span> <span class="toc-text">初始化 wip 树</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#beginWork"><span class="toc-number">1.2.2.4.</span> <span class="toc-text">beginWork</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#hostRootFiber-beginWork%E2%80%94%E2%80%94%E9%A6%96%E5%B1%8F%E6%B8%B2%E6%9F%93%E4%BC%98%E5%8C%96"><span class="toc-number">1.2.2.4.1.</span> <span class="toc-text">hostRootFiber beginWork——首屏渲染优化</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#FC-beginWork"><span class="toc-number">1.2.2.4.2.</span> <span class="toc-text">FC beginWork</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#completeWork"><span class="toc-number">1.2.2.5.</span> <span class="toc-text">completeWork</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#commit-%E9%98%B6%E6%AE%B5"><span class="toc-number">1.2.2.6.</span> <span class="toc-text">commit 阶段</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">1.3.</span> <span class="toc-text">总结</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/posts/38756/" title="用hooks实现componentWillMount"><img src="/img/dog.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="用hooks实现componentWillMount"/></a><div class="content"><a class="title" href="/posts/38756/" title="用hooks实现componentWillMount">用hooks实现componentWillMount</a><time datetime="2023-11-13T06:59:48.000Z" title="发表于 2023-11-13 14:59:48">2023-11-13</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/62212/" title="React的LifeCycle"><img src="/img/lifeCycleImg.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="React的LifeCycle"/></a><div class="content"><a class="title" href="/posts/62212/" title="React的LifeCycle">React的LifeCycle</a><time datetime="2023-11-05T07:02:59.000Z" title="发表于 2023-11-05 15:02:59">2023-11-05</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/51795/" title="你不知道的UseState在mount阶段时所执行时机"><img src="/img/youdonotkonw.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="你不知道的UseState在mount阶段时所执行时机"/></a><div class="content"><a class="title" href="/posts/51795/" title="你不知道的UseState在mount阶段时所执行时机">你不知道的UseState在mount阶段时所执行时机</a><time datetime="2023-11-03T10:03:01.000Z" title="发表于 2023-11-03 18:03:01">2023-11-03</time></div></div></div></div></div></div></main><footer id="footer" style="background: rgba(220,220,220,0)"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By samllBin</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><div class="js-pjax"></div><script src="/js/sakura.js"></script><script src="/js/mouse_move.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>